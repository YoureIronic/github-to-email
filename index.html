<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="description" content="Search any GitHub username or repository and obtain their email addresses.">
    <meta name="keywords" content="information, csint, osint, intelligence, investigation, data analysis, cyber security, GitHub, email lookup, contributor emails, GitHub API, software development, programming, open source, data privacy, digital forensics, cybersecurity tools">
    <meta name="author" content="YoureIronic">
    <meta name="robots" content="index, follow">

    <meta name="color-scheme" content="light">
    <meta name="theme-color" content="#FFFFFF">
    
    <meta property="og:title" content="GitHub to Email">
    <meta property="og:description" content="Search any GitHub username or repository and obtain their email addresses.">
    <meta property="og:url" content="https://youreironic.github.io/github-to-email">
    <meta property="og:type" content="website">
    <meta property="og:locale" content="en_US">
    
    <meta name="twitter:title" content="GitHub to Email">
    <meta name="twitter:description" content="Search any GitHub username or repository and obtain their email addresses.">
    
    <title>GitHub to Email</title>
</head>
<body>
    <h1>GitHub to Email</h1>
    <form id="tokenForm">
        <label for="token">Optional: Enter your GitHub Personal Access Token (PAT):</label>
        <input type="text" id="token" placeholder="Enter your token here">
        <p>Note: To create a token, go to GitHub > Settings > Developer settings > Personal access tokens > Tokens (classic) > Generate new token > Generate new token (classic). Ensure the following scopes are enabled:</p>
        <ul>
            <li>repo (for accessing private repositories)</li>
            <li>public_repo (for accessing public repositories)</li>
        </ul>
        <p>This allows you to send more requests to GitHub's API without being rate limited.</p>
        <button type="submit">Set Token</button>
    </form>
    
    <label><input type="checkbox" id="cacheResults"> Cache usernames and emails to Formspree (this does not log anything but those)</label>
    
    <form id="usernameForm">
        <label for="username">Enter GitHub username:</label>
        <input type="text" id="username" placeholder="GitHub" required>
        <button type="submit">Find Emails</button>
    </form>
    
    <form id="repoForm">
        <label for="repo">Enter GitHub URL repo:</label>
        <input type="text" id="repo" required>
        <button type="submit">Find Contributors' Emails</button>
    </form>
    
    <p id="result"></p>

    <script>
        let GITHUB_TOKEN = '';
        let cachedData = [];

        function checkStoredToken() {
            const storedTokenData = localStorage.getItem('githubTokenData');
            if (storedTokenData) {
                const { token, expiration } = JSON.parse(storedTokenData);
                const expirationDate = new Date(expiration);
                const now = new Date();
                if (expirationDate > now) {
                    GITHUB_TOKEN = token;
                    document.getElementById('token').value = token;
                    console.log('Loaded valid token from localStorage');
                } else {
                    localStorage.removeItem('githubTokenData');
                    console.log('Stored token has expired and was removed');
                }
            }
        }

        checkStoredToken();

        document.getElementById('tokenForm').addEventListener('submit', function(event) {
            event.preventDefault();
            const token = document.getElementById('token').value;
            GITHUB_TOKEN = token;

            if (token && confirm('Do you want to save this token to localStorage for future use?')) {
                const dateInput = prompt('Enter expiration date for the token (YYYY-MM-DD):');
                if (dateInput) {
                    const expirationDate = new Date(dateInput);
                    if (!isNaN(expirationDate.getTime())) {
                        const tokenData = {
                            token,
                            expiration: expirationDate.toISOString()
                        };
                        localStorage.setItem('githubTokenData', JSON.stringify(tokenData));
                        alert('Token saved to localStorage with expiration date: ' + expirationDate.toDateString());
                    } else {
                        alert('Invalid date format. Token not saved to localStorage.');
                    }
                } else {
                    alert('No expiration date provided. Token not saved to localStorage.');
                }
            }

            alert('Token set successfully! You can now use it for API requests.');
        });

        document.getElementById('usernameForm').addEventListener('submit', async function(event) {
            event.preventDefault();
            const username = document.getElementById('username').value;
            const cache = document.getElementById('cacheResults').checked;
            const emails = await getEmails(username);
            displayResult(emails);
            if (cache && emails.length > 0) {
                cachedData.push({ username, emails });
                await submitToFormspree(username, emails);
            }
        });

        document.getElementById('repoForm').addEventListener('submit', async function(event) {
            event.preventDefault();
            const url = document.getElementById('repo').value;
            const cache = document.getElementById('cacheResults').checked;
            const { owner, repo } = parseRepoUrl(url);
            if (owner && repo) {
                const emails = await getEmailsRepo(owner, repo);
                displayResult(emails);
                if (cache && Object.keys(emails).length > 0) {
                    Object.entries(emails).forEach(([username, emailArray]) => {
                        if (emailArray.length > 0) {
                            cachedData.push({ username, emails: emailArray });
                            submitToFormspree(username, emailArray);
                        }
                    });
                }
            } else {
                displayResult([]);
            }
        });

        async function submitToFormspree(username, emails) {
            if (username.length > 39) {
                alert('Username exceeds 39 characters and cannot be sent to Formspree.');
                return;
            }
        
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
        
            for (const email of emails) {
                if (!emailRegex.test(email)) {
                    console.warn(`Skipping invalid email: ${email}`);
                    continue;
                }
        
                let attempts = 0;
                const maxAttempts = 3;
        
                while (attempts < maxAttempts) {
                    try {
                        const response = await fetch('https://formspree.io/f/xrbaygqv', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Accept': 'application/json'
                            },
                            body: JSON.stringify({
                                username,
                                email
                            })
                        });
        
                        if (response.ok) {
                            console.log(`Successfully sent ${username} with ${email} to Formspree`);
                            break;
                        } else if (response.status === 429) {
                            const retryAfter = response.headers.get('Retry-After') || 60;
                            console.warn(`Rate limit hit for ${email}. Waiting ${retryAfter} seconds.`);
                            await delay(retryAfter * 1000);
                            attempts++;
                        } else {
                            const errorData = await response.json();
                            console.error(`Formspree submission failed for ${email}:`, errorData);
                            break;
                        }
                    } catch (error) {
                        console.error(`Error submitting ${email} to Formspree:`, error);
                        break;
                    }
                }
        
                if (attempts >= maxAttempts) {
                    console.error(`Failed to submit ${email} to Formspree after ${maxAttempts} attempts due to rate limiting.`);
                }
        
                await delay(1000);
            }
        }

        async function getEmails(username) {
            const url = `https://api.github.com/users/${username}/events/public`;
            const emailSet = new Set();
            try {
                const response = await fetch(url, {
                    headers: {
                        'Authorization': GITHUB_TOKEN ? `token ${GITHUB_TOKEN}` : undefined
                    }
                });
                if (response.ok) {
                    const events = await response.json();
                    for (const event of events) {
                        if (event.type === 'PushEvent') {
                            for (const commit of event.payload.commits) {
                                if (commit.author && commit.author.email) {
                                    emailSet.add(commit.author.email);
                                }
                            }
                        }
                    }
                } else {
                    handleRateLimit(response);
                }
            } catch (error) {
                console.error('Error:', error);
            }
            const emailsArray = Array.from(emailSet);
            return emailsArray;
        }

        async function getEmailsRepo(owner, repo) {
            const url = `https://api.github.com/repos/${owner}/${repo}/contributors`;
            const emailMap = {};
            try {
                const response = await fetch(url, {
                    headers: {
                        'Authorization': GITHUB_TOKEN ? `token ${GITHUB_TOKEN}` : undefined
                    }
                });
                if (response.ok) {
                    const contributors = await response.json();
                    for (const contributor of contributors) {
                        const emails = await getEmails(contributor.login);
                        emailMap[contributor.login] = Array.isArray(emails) ? emails : [];
                    }
                } else {
                    handleRateLimit(response);
                }
            } catch (error) {
                console.error('Error:', error);
            }
            return emailMap;
        }

        function handleRateLimit(response) {
            if (response.status === 403) {
                const resetTime = response.headers.get('X-RateLimit-Reset');
                const waitTime = resetTime ? (new Date(resetTime * 1000) - new Date()) / 1000 : 60;
                alert(`Rate limit exceeded. Please wait ${Math.ceil(waitTime)} seconds.`);
            }
        }

        function parseRepoUrl(url) {
            const regex = /https:\/\/github\.com\/([^\/]+)\/([^\/]+)/;
            const match = url.match(regex);
            if (match) {
                return { owner: match[1], repo: match[2] };
            }
            return { owner: null, repo: null };
        }

        function displayResult(data) {
            const resultElement = document.getElementById('result');

            if (Array.isArray(data)) {
                if (data.length > 0) {
                    resultElement.innerHTML = `<pre>Emails found: ${data.join(', ')}</pre>`;
                } else {
                    resultElement.textContent = "No emails found for this user.";
                }
            } else if (typeof data === 'object' && data !== null) {
                if (Object.keys(data).length > 0) {
                    const resultText = Object.entries(data)
                        .map(([username, emails]) => {
                            if (Array.isArray(emails) && emails.length > 0) {
                                return `${username}: ${emails.join(', ')}`;
                            } else {
                                return `${username}: No valid emails found.`;
                            }
                        })
                        .join('\n');
                    resultElement.innerHTML = `<pre>${resultText}</pre>`;
                } else {
                    resultElement.textContent = "No emails found for this repository.";
                }
            } else {
                resultElement.textContent = "No emails found.";
            }
        }
    </script>
</body>
</html>
